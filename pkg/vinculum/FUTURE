origin?

redis pubsub bridge

mqtt bridge

suserator / polyfluent

warpctl subscribe -H headers -U username -p password -A auth




func checkOrigin(r *http.Request) bool {
    origin := r.Header.Get("Origin")
    if origin == "" {
        // Non-browser client (likely) â€” safe to allow if you use auth
        return true
    }
    u, err := url.Parse(origin)
    if err != nil {
        return false
    }
    // Compare the host of the Origin to the host of the request
    return u.Host == r.Host
}

func wsHandler(w http.ResponseWriter, r *http.Request) {
    if !checkOrigin(r) {
        http.Error(w, "Forbidden", http.StatusForbidden)
        return
    }
    conn, err := websocket.Accept(w, r, nil) // no InsecureSkipVerify
    if err != nil {
        // handle err
        return
    }
    defer conn.Close(websocket.StatusInternalError, "the sky is falling")

    // ...
}


-----


package main

import (
	"log"
	"net/http"
	"strings"

	"github.com/coder/websocket"
)

func wsHandler(w http.ResponseWriter, r *http.Request) {
	// Strip port from Host if present, because browsers include port in Origin host
	host := r.Host
	if idx := strings.Index(host, ":"); idx != -1 {
		host = host[:idx]
	}

	// Dynamically build AcceptOptions allowing only same-origin requests
	opts := &websocket.AcceptOptions{
		OriginPatterns: []string{host},
	}

	conn, err := websocket.Accept(w, r, opts)
	if err != nil {
		// The handshake failed (e.g., Origin mismatch) â€” respond accordingly
		log.Printf("websocket accept error: %v", err)
		return
	}
	defer conn.Close(websocket.StatusInternalError, "server error")

	// Normal WebSocket handling here
	log.Printf("New websocket connection from %s", r.RemoteAddr)
	for {
		typ, msg, err := conn.Read(r.Context())
		if err != nil {
			log.Printf("read error: %v", err)
			break
		}
		// Echo back
		if err := conn.Write(r.Context(), typ, msg); err != nil {
			log.Printf("write error: %v", err)
			break
		}
	}
}

func main() {
	http.HandleFunc("/ws", wsHandler)
	log.Println("listening on :8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}


---


Would you also like a version that tolerates Origin not being set (for non-browser clients) but still restricts browser connections? (Common when mixing browser and backend clients.)

package main

import (
	"log"
	"net/http"
	"net/url"
	"strings"

	"github.com/coder/websocket"
)

// dynamicAcceptOptions builds AcceptOptions dynamically based on request headers.
func dynamicAcceptOptions(r *http.Request) *websocket.AcceptOptions {
	origin := r.Header.Get("Origin")
	if origin == "" {
		// No Origin header (likely non-browser client)
		// -> Skip verification; accept the connection
		return &websocket.AcceptOptions{
			InsecureSkipVerify: true, // means "don't check Origin"
		}
	}

	// Parse Origin, extract host without port
	u, err := url.Parse(origin)
	if err != nil {
		// Malformed Origin â€” safest to reject
		return &websocket.AcceptOptions{}
	}

	originHost := u.Hostname() // strips port automatically
	reqHost := r.Host
	if idx := strings.Index(reqHost, ":"); idx != -1 {
		reqHost = reqHost[:idx] // strip port
	}

	if originHost == reqHost {
		// Browser connection from same-origin
		// -> Allow only that host
		return &websocket.AcceptOptions{
			OriginPatterns: []string{reqHost},
		}
	}

	// Otherwise: origin mismatch -> no allowed origins
	return &websocket.AcceptOptions{}
}

func wsHandler(w http.ResponseWriter, r *http.Request) {
	opts := dynamicAcceptOptions(r)

	conn, err := websocket.Accept(w, r, opts)
	if err != nil {
		log.Printf("websocket accept error: %v", err)
		http.Error(w, "Forbidden", http.StatusForbidden)
		return
	}
	defer conn.Close(websocket.StatusInternalError, "server error")

	log.Printf("New websocket connection from %s", r.RemoteAddr)
	for {
		typ, msg, err := conn.Read(r.Context())
		if err != nil {
			log.Printf("read error: %v", err)
			break
		}
		if err := conn.Write(r.Context(), typ, msg); err != nil {
			log.Printf("write error: %v", err)
			break
		}
	}
}

func main() {
	http.HandleFunc("/ws", wsHandler)
	log.Println("listening on :8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}

----
Would you like me to annotate this version with comments explaining which lines youâ€™d tweak later if you do know the deployment hostnames (so you can turn the dynamic logic into a fixed allow-list)?

package main

import (
	"log"
	"net/http"
	"net/url"
	"strings"

	"github.com/coder/websocket"
)

// dynamicAcceptOptions builds AcceptOptions based on request headers.
//
// Default logic (safe fallback):
//   - No Origin header (non-browser clients): allow (skip origin check).
//   - Origin present and matches request host: allow.
//   - Origin present and mismatched: reject.
func dynamicAcceptOptions(r *http.Request) *websocket.AcceptOptions {
	origin := r.Header.Get("Origin")
	if origin == "" {
		// ðŸŸ¢ TWEAK POINT 1:
		// If you *never* expect non-browser clients, you could reject here.
		// Current behavior allows clients without Origin (likely CLI/mobile apps).
		return &websocket.AcceptOptions{
			InsecureSkipVerify: true, // disables origin check only
		}
	}

	u, err := url.Parse(origin)
	if err != nil {
		// ðŸŸ¢ TWEAK POINT 2:
		// Malformed Origin â†’ safest to reject.
		// If you prefer being permissive, you could also allow here.
		return &websocket.AcceptOptions{}
	}

	originHost := u.Hostname() // strips port automatically
	reqHost := r.Host
	if idx := strings.Index(reqHost, ":"); idx != -1 {
		reqHost = reqHost[:idx] // normalize by stripping port
	}

	if originHost == reqHost {
		// ðŸŸ¢ TWEAK POINT 3:
		// Browser connection from same-origin â†’ allow.
		// If you later *know* your allowed host(s), you can replace this:
		//     return &websocket.AcceptOptions{ OriginPatterns: []string{"yourhost.com"} }
		return &websocket.AcceptOptions{
			OriginPatterns: []string{reqHost}, // allow only current host
		}
	}

	// ðŸŸ¢ TWEAK POINT 4:
	// Mismatched origin â†’ reject.
	// If you later want to allow staging or partner domains, add them here:
	//     return &websocket.AcceptOptions{ OriginPatterns: []string{"yourhost.com", "staging.yourhost.com"} }
	return &websocket.AcceptOptions{}
}

func wsHandler(w http.ResponseWriter, r *http.Request) {
	opts := dynamicAcceptOptions(r)

	conn, err := websocket.Accept(w, r, opts)
	if err != nil {
		log.Printf("websocket accept error: %v", err)
		http.Error(w, "Forbidden", http.StatusForbidden)
		return
	}
	defer conn.Close(websocket.StatusInternalError, "server error")

	log.Printf("New websocket connection from %s", r.RemoteAddr)
	for {
		typ, msg, err := conn.Read(r.Context())
		if err != nil {
			log.Printf("read error: %v", err)
			break
		}
		if err := conn.Write(r.Context(), typ, msg); err != nil {
			log.Printf("write error: %v", err)
			break
		}
	}
}

func main() {
	http.HandleFunc("/ws", wsHandler)
	log.Println("listening on :8080")
	log.Fatal(http.ListenAndServe(":8080", nil))
}


Recap of tweak points
Tweak Point	Current behavior	What youâ€™d change later
1	Allow connections without Origin (non-browser).	Disallow if only browsers should connect.
2	Reject malformed Origin.	Allow or log differently if you have special clients.
3	Allow same-host browser connections.	Replace with explicit list of known deployment hosts.
4	Reject cross-origin browser connections.	Add staging, QA, or partner domains to OriginPatterns.

ðŸ’¡ This way, youâ€™ve got a secure default that works everywhere, and you can gradually tighten it as soon as your deployment topology stabilizes.


